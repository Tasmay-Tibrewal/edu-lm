[
  {
    "video_name": "5 ways to shoot yourself in the foot with C - Fireship 720p, h264 - Copy.mp4",
    "video_id": 0,
    "video_info_available": 1,
    "video_content": [
      {
        "video_timestamp_num": 0,
        "timestamp_start": "00:00:00",
        "timestamp_end": "00:00:39",
        "timestamp_transcript_content": {
          "content_type": "text",
          "content": "ISO/IEC 9899 is arguably the most important document in the history of humankind. More significant than the Magna Carta, has built more wealth than Satoshi's Bitcoin white paper, and is even more sacred than the moon landing telemetry data which was lost by NASA. This document is the official spec for the C programming language. The mother of almost all modern languages like C++, Java, JavaScript, Python, and is also the foundation for operating systems, compilers, encryption tools, game engines, and smart toilets. It's a simple, humble language that built the world, but sometimes it also likes to destroy the world. In today's video, we'll look at five simple code examples of memory management in C. Five code examples that go hard."
        },
        "timestamp_description_content": {
          "content_type": "text",
          "content": "The video opens with a dramatic, almost reverent tone, introducing **ISO/IEC 9899** as \"arguably the most important document in the history of humankind.\" Visually, the text \"ISO/IEC 9899\" is displayed prominently with a silhouette of a person looking towards a bright light, symbolizing its significance. The speaker humorously exaggerates its importance, comparing it to the Magna Carta, Satoshi's Bitcoin white paper, and even NASA's lost moon landing telemetry data, all while displaying images of these historical and technological artifacts. This sets a tone of both respect and lightheartedness. \\n\\nAt 00:00:15, the video transitions to show the cover of the **ISO/IEC 9899:2024** document, specifying it as the official specification for the C programming language. The speaker emphasizes C's foundational role, calling it \"the mother of almost all modern languages\" (00:00:19). As he lists languages like C++, C#, Java, JavaScript, Python, and PHP, their respective logos appear around an ancient painting of a matriarchal figure, reinforcing C's role as the \"mother language.\" \\n\\nThe video further illustrates C's broad impact by showing various applications it underpins: Linux (represented by Tux the penguin), Cython, raw binary data (representing operating systems and compilers), Unreal Engine (for game engines), and even a futuristic smart toilet (humorously representing everyday devices). \\n\\nThe speaker then notes that while C is a \"simple, humble language that built the world,\" it can also \"destroy the world,\" accompanied by an animation of a globe shattering. This serves as a pivot to the video's main topic: five simple code examples of memory management in C that highlight its potential dangers, described as \"code that's cost companies billions of dollars and put programmers in jail.\""
        }
      },
      {
        "video_timestamp_num": 1,
        "timestamp_start": "00:00:39",
        "timestamp_end": "00:01:23",
        "timestamp_transcript_content": {
          "content_type": "text",
          "content": "Code that's cost companies billions of dollars and put programmers in jail. But you might be saying to yourself, wait a minute, I'm just a soydev who relies on garbage collection and this is above my pay grade. Well, actually, memory management in C is something you can learn in 30 seconds. C forces you to grow up and manage memory by yourself. That means if you want to put some data into the computer's RAM, you allocate some bytes with the `malloc` function. It returns a memory address that looks like this, which you can then access in your code using a pointer, which itself is just a variable that points to a memory address. And now we can start putting crap in it, but every `malloc` also needs a `free`, which will release the memory when you're done with it. That's pretty much all there is to it, and it didn't even take 30 seconds to master it. But with great power comes a million different ways to shoot yourself in the foot."
        },
        "timestamp_description_content": {
          "content_type": "text",
          "content": "The speaker continues with the dramatic tone, showing a police officer typing on a computer with an \"EVIDENCE\" bag in the foreground, suggesting the serious consequences of memory management errors. He then addresses a common developer's perspective, humorously referring to them as \"soydevs who rely on garbage collection\" and might find C's manual memory management intimidating. \\n\\nHe quickly counters this by stating that memory management in C can be learned in \"30 seconds.\" The video transitions to a minimalistic dark screen with a large 'C' and a countdown timer from 00:00:29. A hand in a white glove is shown inserting a RAM stick into a slot, visually representing C's direct interaction with memory. \\n\\nAt 00:00:58, a code editor appears, displaying a basic C program with `main()` function. The speaker explains the fundamental steps: \\n1.  **Allocation**: Using the `malloc` function to allocate memory. An example `char *buffer = malloc(100);` is shown. He clarifies that `malloc` returns a memory address (e.g., `0x7ffe5367e069`), which is then accessed via a pointer. A pointing finger emoji highlights `*buffer`. \\n2.  **Usage**: Data can then be put into the allocated memory, demonstrated by `strcpy(buffer, "
        }
      },
      {
        "video_timestamp_num": 2,
        "timestamp_start": "00:01:23",
        "timestamp_end": "00:02:59",
        "timestamp_transcript_content": {
          "content_type": "text",
          "content": "Like don't call free twice. Don't use freed memory. Don't call free after midnight. And definitely don't forget to do bounds checking. One of the first large scale attacks on the internet was the Morris Worm. In 1988, it took out about 6,000 machines, which at the time was 10% of the internet. And it was able to do that because libraries like fingerd and sendmail had code that looked similar to this. Here we have a buffer with 512 bytes. Then we put some data into it, but the problem is we're not checking the size, which could result in a buffer overflow. This allowed the worm to overwrite return addresses on the stack, allowing for arbitrary code execution. That's because C doesn't automatically perform bounds checking. And if you try to do something like access an array out of bounds, it leads to undefined behavior. But this can be fixed in a variety of ways, with the most simple approach being a conditional statement. The creator of the Morris Worm almost ended up in prison, but it's nowhere near as bad as Heartbleed in 2014. OpenSSL used an extension called Heartbeat, which was designed to keep a connection between a client and server alive. What's supposed to happen on a normal heartbeat is the client sends a message like, I'm sending five bytes with the message hello. Then the server will echo back hello. Simple enough, but it was missing one thing. The code didn't actually verify that the number of bytes matched the actual length of the value. That allowed attackers to send a malicious heartbeat where the client would say, I'm sending 64,000 bytes with a value of hello. Then the server would copy back all those 64,000 bytes, which could contain sensitive information like private encryption keys, passwords, and so on. And because this bug occurred on OpenSSL, which is encryption software that powers millions of websites, fixing it became a massive disaster."
        },
        "timestamp_description_content": {
          "content_type": "text",
          "content": "The video outlines a list of memory management commandments: \"1. Don't call free twice,\" \"2. Don't use freed memory,\" \"3. Don't call free after midnight,\" and \"4. Don't forget bounds checking.\" (The \"Don't call free after midnight\" is a humorous addition, while the others are critical. The list updates as new points are introduced, maintaining the numbering). \\n\\n**Case Study 1: Bad Bounds Checking (Morris Worm)** \\nAt 00:01:31, the video introduces the Morris Worm, one of the first large-scale internet attacks in 1988, which took down about 6,000 machines (10% of the internet at the time). A split screen shows a picture of Robert Tappan Morris, the creator, and a display with \"The Morris Internet Worm source code.\" The speaker explains that vulnerabilities in libraries like `fingerd` and `sendmail` led to this attack. \\n\\nA code snippet is then displayed, showing a `vulnerable_function` with a `char buffer[8];` (initially stated as 512 bytes in the audio, but the visual code shows 8 bytes, which is a common small buffer example). The `strcpy(buffer, input);` line is highlighted. The core issue is explained: **no bounds checking** on the `input` length allows an attacker to write more data than the buffer can hold, leading to a **buffer overflow**. This is visually emphasized with a pointing finger and the text \"could put anything here.\" \\n\\nThis buffer overflow allowed the worm to overwrite return addresses on the stack, enabling **Remote Code Execution** (illustrated with a network diagram showing how the worm spread). The speaker stresses that C *does not* automatically perform bounds checking. Executing an array out of bounds leads to \"undefined behavior,\" which can crash the program or allow attackers to execute arbitrary code. He then shows a simple fix using `strncpy` with `sizeof(buffer) - 1`, acknowledging \"many ways to fix\" such issues. The creator of the Morris Worm almost went to prison due to this bug. \\n\\n**Case Study 2: Heartbleed (No Length Verification)** \\nAt 00:02:15, the video introduces the Heartbleed bug from 2014, an even more severe vulnerability, by showing a man clutching his chest with a \"2. HEARTBLEED BOUNDS CHECK\" overlay. The bug occurred in **OpenSSL**, a widely used cryptography and SSL/TLS toolkit. \\n\\nThe video explains the Heartbeat extension in OpenSSL, designed to keep client-server connections alive. Normally, a client sends a message (e.g., \"hello\" - 5 bytes), and the server echoes it back. However, the Heartbleed code (`memcpy(response, data, claimed_length);`) lacked **length verification** (highlighted with an arrow and \"NO LENGTH VERIFICATION\"). \\n\\nThis allowed a malicious client to claim a much larger message length (e.g., 64,000 bytes) while sending only a small actual message (\"hello\"). The server would then copy those 64,000 bytes, including sensitive data from its memory (like private encryption keys and passwords), and send it back to the client. This vulnerability, affecting millions of websites, was a \"massive disaster\" to fix, visually represented by the OpenSSL logo engulfed in flames."
        }
      },
      {
        "video_timestamp_num": 3,
        "timestamp_start": "00:02:59",
        "timestamp_end": "00:03:50",
        "timestamp_transcript_content": {
          "content_type": "text",
          "content": "But another way to mess up C code is to use memory after it's been freed. And that's exactly what happened to Internet Explorer in 2013. The C code looks like this, where you allocate some memory, free it, and then try to use it again somewhere later in the code. In this case, the code lived in Internet Explorer 8 and was meant to free up memory when JavaScript code would remove elements from an HTML page. However, the pointer to the freed object still exists in Internet Explorer's internal structure, and that allowed attackers to set up malicious websites that could take control of your system by doing nothing more than visiting a website. That's not good, but when working with C, it's also important to know how to count properly. Because being off-by-one can lead to catastrophic results. In this code example, we're using a function from the C standard library to append some values to a string. But because we didn't take into account a null-terminating character, we're going to get yet another buffer overflow."
        },
        "timestamp_description_content": {
          "content_type": "text",
          "content": "The video moves to the third common C memory error: **Use After Free**. A frantic-looking programmer at a laptop is shown, with the text \"3. USE AFTER FREE\" overlayed. This vulnerability was exploited in **Internet Explorer in 2013**, shown with a vintage Windows 95 desktop displaying the IE icon. \\n\\nThe code snippet demonstrates the issue: memory is allocated with `malloc`, then immediately `free`d, but the program later attempts to access or modify that freed memory (`elem->value = 69;`) under a certain condition. This is explicitly labeled \"BAD MOVE.\" \\n\\nThe speaker explains that in Internet Explorer 8, this code was intended to free memory when JavaScript removed HTML elements from a page. However, the pointer to the freed object lingered in IE's internal structure. Attackers exploited this by creating malicious websites that, simply by being visited, could trigger this \"use after free\" bug, allowing them to take control of the user's system. This is dramatically illustrated by a \"WARNING! YOUR COMPUTER MAY BE INFECTED\" pop-up. \\n\\n**Case Study 4: Off-by-One Errors** \\nAt 00:03:30, the video shifts to the fourth pitfall: **Off-by-One** errors. A man is shown counting on his fingers, then shaking his head, while the text \"4. OFF-BY-ONE\" appears. The speaker stresses the importance of correct counting in C to avoid \"catastrophic results.\" \\n\\nThe code example shows two strings, `str1 = "
        }
      },
      {
        "video_timestamp_num": 4,
        "timestamp_start": "00:03:50",
        "timestamp_end": "00:05:00",
        "timestamp_transcript_content": {
          "content_type": "text",
          "content": "And finally, that brings us to Double Free. In this code here, you'll notice that we're freeing the same memory twice in two different parts of the program. Freeing memory twice may not sound like a big deal, but it leads to undefined behavior, at which point your code sucks and all bets are off. Your program might work fine, it might crash, or it could allow an attacker to write arbitrary values in memory. As you can C, C can be dangerous, but it's the foundation for all sorts of amazing software, like everybody's favorite SQL database, Postgres. And that's why you need to know about Gel, the sponsor of today's video. A next-gen Postgres database platform that lets you model your data with simple types instead of tables. Not only is it more natural to work with, but it also provides total type safety, graph-like modeling, and painless schema migration. Gel's type-safe query builder gives you all the power of SQL, but with modern tooling that makes it feel like you're programming in 2025, not 2005. You can use their Next.js starter template like I'm doing here to get up and running in just a few minutes, and you can use their built-in auth and AI solutions to add more advanced features over time. Try out Gel with the link below to get started today. Thanks for watching, and I will see you in the next one."
        },
        "timestamp_description_content": {
          "content_type": "text",
          "content": "The final memory management pitfall is presented: **Double Free**. The visual is a still from *The Shining* showing the Grady twins, known for their eerie repetition, with the text \"5. DOUBLE FREE.\" This effectively symbolizes the act of freeing memory twice. \\n\\nThe code example shows a `cleanup_user_data` function that calls `free(u->groups)`. The `process_user` function then calls `cleanup_user_data(&u)` once, and conditionally calls it a second time (`if (error_condition) { cleanup_user_data(&u); }`). Two pointing finger emojis highlight the two `cleanup_user_data(&u)` calls. The speaker warns that freeing memory twice, while seemingly minor, leads to \"undefined behavior,\" implying unpredictability where the code \"sucks and all bets are off.\" The program might work, crash, or, critically, allow an attacker to write arbitrary values to memory. The visual transitions to static noise with code overlaid, then a close-up of a person's glasses reflecting green code, emphasizing the potential for malicious code injection. \\n\\n**Conclusion and Sponsor Segment** \\nAt 00:04:10, the video transitions to its conclusion with the text \"AS YOU CAN C\" (playing on the word \"see\"). The speaker reiterates that C \"can be dangerous\" but is also the \"foundation for all sorts of amazing software.\" This is humorously illustrated with a meme of an astronaut pointing a gun at another astronaut, who asks, \"Wait, is it all just C?\" and the first astronaut replies, \"Always has been.\" Various programming language logos (Java, Python, R, C#, Linux, C++) are shown on a globe behind them, with C++ and C being prominent in the foreground and a PostgreSQL elephant logo appearing over the globe, highlighting its C foundation. \\n\\nThe video then seamlessly transitions to a sponsor message for **Gel** at 00:04:18. Gel is introduced as a \"next-gen Postgres database platform\" that allows modeling data with \"simple types instead of tables,\" which is displayed over a code editor showing a `type File extending Timestamped` definition, with the text \"TYPES NOT TABLES.\" \\n\\nThe speaker highlights Gel's benefits: more natural workflow, total type safety, graph-like modeling, and painless schema migration. He shows an example of Gel's type-safe query builder, which offers the power of SQL with \"modern tooling that makes it feel like you're programming in 2025, not 2005.\" The video also briefly shows Gel's visual schema designer. The speaker encourages viewers to try Gel, mentioning its Next.js starter template and built-in authentication and AI solutions. The video ends with the Gel logo and website (`www.geldata.com`)."
        }
      }
    ]
  }
]